# Действия и события

Важным свойством любого приложения является обработка действий пользователя и реакция пользовательского интерфейса (UI) на эти действия.

Duit предоставляет мощный и расширяемый событийно-ориентированный API, который позволяет описывать на сервере специальные структуры, определяющие, как фреймворк должен реагировать на взаимодействие с элементами UI и то, каким образом должен быть изменен интерфейс в результате взаимодействия. За это отвечает Action&Event API.

## Действия

Действие - описанная на стороне сервера структура, определяющая что должно произойти после взаимодействия.

В Duit существует три основных типа действий. Они отличаются друг от друга тем, как они будут обработаны и какие механизмы фреймворка будут задействованы.

### TransportAction

TransportAction - действия, задействующие [транспортный слой](/docs/core_concepts/transport_layer) Duit. Описание действия содержит название эндпоинта на стороне сервера, к которому будет идти обращение в ходе выполнения, список зависимостей действия, а также опционально дополнительные данные (HttpActionMetainfo).

```json
{
    "executionType": 0 // 0 - transport, 1 - local, 2 - script
    "dependsOn": [
        {"tagret": "key_in_obj", "id":"id1"}
        {"tagret": "key_in_ob2j", "id":"id2"}
    ],
    "event": "/some/endpoint",
    "meta": {
        "method": "POST",
    },
}
```

### LocalAction

Локальное действие мгновенно выполняет связанное событие или группу событий. Оно может быть полезно, когда надо изменить состояние UI, но обращение к серверу для этого не требуется.

```json
{
    "executionType": 1 // 0 - transport, 1 - local, 2 - script
    "event": {...}, //related event
}
```

### ScriptAction

Специальный тип действия, который содержит в своем описании динамический скрипт, который будет выполняться в интегрированной среде выполенения. Подробнее об использовании скриптов читайте в соотвествующем [разделе](/docs/advanced_tech/scripting) документации.

```json
{
    "executionType": 2 // 0 - transport, 1 - local, 2 - script
    "dependsOn": [
        {"tagret": "key_in_obj", "id":"id1"}
        {"tagret": "key_in_ob2j", "id":"id2"}
    ],
    "script": {
        "sourceCode": "fun test() {...}", //script text
        "functionName": "test", //function to call
        "meta": {...} //additional info
    }
}
```

## Опции выполнения действий

Duit предоставляет возможность управления частотой выполнения действий через механизм `ExecutionOptions`. Это позволяет контролировать, как часто действие может быть выполнено, что особенно полезно для предотвращения излишних запросов к серверу.

### ExecutionOptions

Опции выполнения действий поддерживают два модификатора:

- **`throttle`** - ограничивает частоту выполнения действия. Действие будет выполнено максимум один раз за указанный период времени. При повторных вызовах в течение периода выполнения будут игнорироваться.
- **`debounce`** - откладывает выполнение действия до окончания периода бездействия. Выполнение откладывается до тех пор, пока не пройдет указанное время без новых вызовов.

```json
{
    "executionType": 0,
    "dependsOn": [...],
    "event": "/some/endpoint",
    "meta": {
        "method": "POST"
    },
    "executionOptions": {
        "modifier": "throttle",
        "duration": 500
    }
}
```

Пример для debounce:

```json
{
    "executionType": 0,
    "event": "/search",
    "executionOptions": {
        "modifier": "debounce",
        "duration": 300
    }
}
```

## Зависимости действий

В ходе работы с приложением пользователь может использовать такие элементы UI, как TextField, CheckBox, Radio и тд. Использование подобных элементов подразумевает сбор и использование данных, которые ввел пользователь.

Для работы с такими случаями `TransportAction` и `ScriptAction` обладают свойством `dependsOn`, которое является списоком объектов вида `{"tagret": "key_in_obj", "id":"id1"}` (где target - ключ свойства результирущего объекта, а id - идентификатор контроллируемого виджета), из которых требуется собрать значения и использовать при выполнении действия.

При выполнении действия, для которого указаны зависимости, Duit попытается обратиться к контроллерам этих элементов для получения их текущих значений из атрибутов. Классы атрибутов, которые могут изменять в ходе работы свое хранимое значение и имеют геттер для его получения, наследуются от класса `AttendedModel<T>`. Например, класс [TextFieldAttributes](https://github.com/Duit-Foundation/flutter_duit/blob/main/lib/src/attributes/text_field_attrs.dart).

В ходе сбора данных согласно списку зависимостей будет создан результирующий объект с данными. Далее он будет передан транспортному слою, который способен подготовить его к передаче. Например, в случае с HTTP GET запросом, объект будет преобразован в query params и добавлен в URL запроса, а в случае POST запроса - добавлен в тело запроса.

Используя этот механизм можно реализовывать формы, данные которых будут отправлены на сервер в ходе выполениния действия.

## События

Событие - результат выполнения действия, описывает поведение UI после его успешного выполнения.
Duit поддерживает несколько видов базовых действий, каждый из которых будет разобран ниже:

### UpdateEvent

Событие отвечает за обновление контрллируемых элементов интерфейса. Описание события содержит объект `updates`,
в котором ключами являются id контрллируемых виджетов (для поиска и использования нужного контроллера), а значениями - новые атрибуты виджета.

```json
{
  "type": "update",
  "updates": {
    "text_1": {
      "data": "New text",
      // "color": "#DCDCDC" сan`t be handled
      "style": {
        "color": "#DCDCDC"
      }
    }
  }
}
```

:::warning
Парсинг новых атрибутов не поддерживает "плоские" значения. Если свойство является сложносоставным (например, TextStyle), оно должно повторять структуру оригинального класса.
:::

### CommandEvent

Событие, которое отправляет команду контроллеру для выполнения специальных операций. Команды позволяют серверу напрямую взаимодействовать с контроллерами виджетов, вызывая специфическое поведение.

```json
{
  "type": "command",
  "controllerId": "some_id",
  "type": "animation",
  "commandData": {
    "animatedPropKey": "style",
    "method": 0, // 0 - forward, 1 - repeat, 2 - reverse, 3 - toggle
    "trigger": "auto" // auto, manual
  }
}
```

Команды поддерживают несколько типов:

- **`animation`** - управление анимацией свойств
- **`bottomSheet`** - показ/скрытие модальных окон (BottomSheet)
- **`dialog`** - показ/скрытие диалоговых окон

Пример команды для показа BottomSheet:

```json
{
  "type": "command",
  "controllerId": "overlay",
  "type": "bottomSheet",
  "commandData": {
    "action": "open",
    "content": {...},
    "isScrollControlled": true,
    "isDismissible": true
  }
}
```

### TimerEvent

Событие, которое будет запущено по истечении таймера. Описание содержит вложенное событие или группу событий и длительность таймера.

```json
{
    "type": "timer",
    "timerDelay": 1000, // in ms
    "event": {...}, //nested event
}
```

### SequencedEventGroup

Группа событий, позволяющиая последовательно выполнять вложенные события с заданным интервалом.

```json
{
    "type": "sequenced",
    "delay": 1000, // in ms
    "events": [
        {...}, //event 1
        {...}, //event 2
        {...}, //event 3
    ], //nested events
}
```

### CommonEventGroup

Группа событий, позволяющиая выполнять вложенные события.

```json
{
    "type": "grouped",
    "events": [
        {...}, //event 1
        {...}, //event 2
        {...}, //event 3
    ], //nested events
}
```

:::warning
Порядок выполнения действий не гарантирован!
:::

### NavigationEvent, OpenUrlEvent и CustomEvent

Эта группа событий требует регистрации внешних обработчиков через метод `attachExternalHandler` драйвера. Вместо использования интерфейса `ExternalEventHandler`, теперь используется механизм регистрации отдельных обработчиков для каждого типа события.

Для регистрации используется перечисление `UserDefinedHandlerKind`, которое определяет тип события:

- `navigation` — для событий навигации (`NavigationEvent`).
- `openUrl` — для открытия внешних ссылок (`OpenUrlEvent`).
- `custom` — для пользовательских событий (`CustomEvent`).

Все обработчики должны соответствовать сигнатуре `UserDefinedEventHandler`:

```dart
typedef UserDefinedEventHandler = FutureOr<void> Function(
  BuildContext context,
  String path,
  Object? extra,
);
```

Пример регистрации обработчиков:

```dart
driver.attachExternalHandler(
  UserDefinedHandlerKind.navigation,
  (context, path, extra) {
    // Логика перехода на другой экран
  },
);

driver.attachExternalHandler(
  UserDefinedHandlerKind.openUrl,
  (context, url, _) {
    // Логика открытия URL
  },
);
```

**NavigationEvent** — применяется в случаях, если необходимо выполнить переход на другой экран приложения, не являющийся Duit-экраном.

**OpenUrlEvent** — предназначено для открытия внешних ссылок в браузере устройства.

**CustomEvent** — специальный тип события, позволяющий обрабатывать события, которые не были предусмотрены разработчиками. Полезно в случаях гибридной интеграции Duit с приложением.

### Внешние потоки событий

Duit позволяет интегрировать внешние источники событий (например, WebSockets, Firebase или события нативной платформы) в систему обработки событий драйвера. События из этих потоков будут автоматически обрабатываться драйвером и могут вызывать обновления UI или выполнение зарегистрированных обработчиков.

Для добавления потока используется метод `addExternalEventStream`:

```dart
final websocketStream = WebSocketChannel.connect(
  Uri.parse('ws://example.com'),
).stream.map((data) => jsonDecode(data) as Map<String, dynamic>);

driver.addExternalEventStream(websocketStream);
```

**Важные особенности:**

- Драйвер автоматически подписывается на поток при его добавлении и отменяет подписку при вызове `dispose`.
- Вы можете добавить несколько потоков, они будут обрабатываться параллельно.
- Структура событий в потоке должна соответствовать ожидаемому формату Duit или обрабатываться зарегистрированными внешними обработчиками.

### NullEvent

Сервисное событие. Парсер событий возвращает его в том случае, если объект события не может быть корректно обработан.
